import { useCallback, useEffect, useRef } from 'react';
import { useSyncedRef } from "../useSyncedRef/useSyncedRef.js";
var cancelTimeout = function (id) {
    if (id) {
        clearTimeout(id);
    }
};
/**
 * Like `setTimeout` but in the form of a react hook.
 *
 * @param callback Callback to be called after the timeout. Changing this
 * will not reset the timeout.
 * @param ms Timeout delay in milliseconds. `undefined` disables the timeout.
 * Keep in mind, that changing this parameter will re-set timeout, meaning
 * that it will be set as new after the change.
 */
export function useTimeoutEffect(callback, ms) {
    var cbRef = useSyncedRef(callback);
    var msRef = useSyncedRef(ms);
    var timeoutIdRef = useRef(null);
    var cancel = useCallback(function () {
        cancelTimeout(timeoutIdRef.current);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    var reset = useCallback(function () {
        if (typeof msRef.current === 'undefined')
            return;
        cancel();
        timeoutIdRef.current = setTimeout(function () { return cbRef.current(); }, msRef.current);
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    useEffect(function () {
        reset();
        return cancel;
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [ms]);
    return [cancel, reset];
}
